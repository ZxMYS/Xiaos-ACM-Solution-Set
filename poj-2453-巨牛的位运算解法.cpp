/*基本思路是:

找出从最右一个不为0(即最右一个1)开始的连续"1"串(假设k个),将其加 1,再将最右端的k-1个0变为1(与原数的1的个数相同);比如原数为0100,0111,0000,则先将从第4位开始往左数连续的3个1加1,则变为0100,1000,0000.再将最低的3-1=2位0变为1,则实现了转变.这一结果显然是正确的.

用的是位运算,实现函数如下:
*/
unsigned snoob(unsigned x)
{
unsigned small,rip,ones;
small=x&-x;                             //析出最右侧的"1"位
rip=x+small;
ones=x^rip;
ones=(ones>>2)/small;
return rip|ones;
}
