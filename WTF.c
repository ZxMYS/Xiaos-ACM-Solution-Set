/*
 * minisort - sort the records in the file generated by the program 'gen_sort'
 *            according to the 'key' (the first 10 bytes) of each record. the result
 *            is ascending order of charactors. If the key of multiple records are
 *            the same, the record with small record number is prior.
 */
#include <stdio.h>
#include <stdlib.h>

static void
usage(char *fn)
{
    /*
     * NOTE: the 'input_filename' is neccessary, and the output_filename is optional
     * if the user don't provide output_filename, then minisort print the result to screen
     */
    printf("usage: %s <input_filename> [output_filename]\n", fn);
}

int
main(int argc, char *argv[])
{
    /* check and get the arguments */
    if (argc < 2) {
        usage(argv[0]);
        exit(EXIT_FAILURE);
    }

    if (argc > 3) {
    	printf("usage: %s <input_filename> [output_filename]\n", argv[0]);
        exit(EXIT_FAILURE);
    }

    /* check and get input file
     * the size of input file should be the multiple of record size (100 bytes)
     */

    /* get input file */
    FILE *input = fopen(argv[1], "r");

    /* construct a structure in order to record the three parts seperately */
    typedef struct {
    	char key[11];
    	char record[11];
    	char value[81];
    }line;

    /* get the number of the lines */
    fseek(input, 0, SEEK_END);
    int count = ftell(input);
    fseek(input, 0, SEEK_SET);
    int lineCount = count / 100;

    /* check the size of the input file */
    if (count % 100 != 0){
    	printf("minisort: The size of the file is not right!");
    	exit(EXIT_FAILURE);
    }else{
	printf("minisort: The size of '%s' file is %d bytes\n", argv[1], count);
    	printf("minisort: Start to sort %d records ...", lineCount);
    }

    /* construct a structure array to save those values in the file*/
    line *strLine = (line *) malloc(lineCount * sizeof(line));

    /* get and assign the value of each part */
	//Vars declared inside functions must have an
	//initial value before begin used.
	//Otherwise it's value is
	//undefined.(i.e. could be any value)
    int i,j=0;
	//less,not less or EQUAL
    while(j < lineCount){
    	char string[101];
    	fgets(string, 101, input);
    	strLine[j].key[10] = '\0';
    	strLine[j].record[10] = '\0';
    	strLine[j].value[80] = '\0';
	//WHY 101??0~99 there are 100 chars
	//WTF!!!
	//YOU SWAPED THE SECOND PHRASE OF 'FOR' FOR THE THIRD!!!
    	for(i=0;i<100;i++){
    		if(i <= 9){
    			strLine[j].key[i] = string[i];
    		}
    		else if(i <= 19){
    			strLine[j].record[i-10] = string[i];
    		}
    		else{
    			strLine[j].value[i-20] = string[i];
    		}
    	}
    	j++;
    }
	//ALWAYS REMEMBER TO CLOSE FILES YOU HAVE OPENDED!
    fclose(input);

    /* do sort */
	//MUST BE VOID * 
    int cmpKey(const void *str1, const void *str2){
	//exploit the struct through -> operator! if you just 
	//see it as char*,why do we define the struct?!
	//PS. type casting here looks over-elaborate and
	//this is one annoying part of C
    	int res = strcmp(((line *)str1)->key, ((line *)str2)->key);
    	if (res == 0){
    		return strcmp(((line *)str1)->record, ((line *)str2)->record);
    	}
    	else{
    		return res;
    	}
    }

	//the second arg is the LENGTH of the array,not the 
	//WHOLE SIZE of the array!
	//thus the third  is the SIZE OF SINGLE ELEMENT
    qsort(strLine, lineCount , sizeof(line), cmpKey);

    /* print the result to screen or output file */
    int k;
    line *p = strLine;

    if(argc == 2){
    	for(k = 0; k < lineCount; k++){
    		printf("%s%s%s", p->key,p->record,p->value);
    		p++;
    	}
    }
    else{
    	FILE *output;
    	output = fopen(argv[2], "w");
    	for(k = 0; k < lineCount; k++){
    		fprintf(output,"%s%s%s", p->key,p->record,p->value);
    		p++;
    	}
	//we MUST close the output file finally.otherwise it
	//may not be written at all!
	fclose(output);
    }

    /* release allocated resource */


    free(strLine);
    printf("minisort: Done.\n");
	//you forgot the last \n here.
    printf("minisort: Succeed to write result (%d records)\n", lineCount);


    return 0;
}


